{
    "version": "1.0",
    "description": "База готовых вопросов для технических собеседований Python/Fullstack",
    "questions": [
        {
            "id": 1,
            "question": "Что такое декоратор в Python?",
            "category": "python_core",
            "answer": "**Декоратор** — это паттерн проектирования, позволяющий расширить поведение функции без изменения её кода.\n\n**Как работает**:\n1. Декоратор — функция, которая принимает функцию и возвращает новую функцию\n2. Использует замыкание (closure) для сохранения ссылки на оригинал\n3. Синтаксис `@decorator` — сахар для `func = decorator(func)`\n\n**Примеры использования**:\n- `@login_required` — проверка авторизации\n- `@cache` — кэширование результатов\n- `@transaction.atomic` — атомарные транзакции в Django\n\nВ своих проектах часто пишу декораторы для логирования, валидации и измерения времени выполнения."
        },
        {
            "id": 2,
            "question": "Чем отличается list от tuple?",
            "category": "python_core",
            "answer": "**Главное отличие**: list — изменяемый (mutable), tuple — неизменяемый (immutable).\n\n**Практические различия**:\n- **Производительность**: tuple быстрее (меньше overhead)\n- **Память**: tuple занимает меньше памяти\n- **Хэшируемость**: tuple можно использовать как ключ dict, list — нельзя\n- **Безопасность**: tuple защищает от случайных изменений\n\n**Когда использовать**:\n- `tuple` — для фиксированных данных (координаты, конфигурация)\n- `list` — для динамических коллекций (результаты запроса, буферы)\n\nВ Django часто использую tuple для `INSTALLED_APPS`, `MIDDLEWARE` — они не должны меняться в runtime."
        },
        {
            "id": 3,
            "question": "Что такое GIL и как он влияет на многопоточность?",
            "category": "python_core",
            "answer": "**GIL (Global Interpreter Lock)** — глобальная блокировка, позволяющая выполнять только один поток Python-кода одновременно.\n\n**Влияние на производительность**:\n- **CPU-bound задачи**: GIL блокирует параллелизм, используйте `multiprocessing`\n- **I/O-bound задачи**: GIL освобождается при I/O, `threading` работает эффективно\n\n**Обходные решения**:\n1. `multiprocessing` — отдельные процессы без GIL\n2. `asyncio` — асинхронность для I/O операций\n3. C-расширения — NumPy, Pandas освобождают GIL\n4. Альтернативные интерпретаторы — PyPy, Jython\n\nВ веб-приложениях GIL редко проблема — большинство операций I/O-bound (БД, HTTP запросы)."
        },
        {
            "id": 4,
            "question": "Расскажите о себе",
            "category": "soft_skills",
            "answer": "Я **Python Backend Developer** с опытом более 3 лет. Специализируюсь на разработке высоконагруженных веб-приложений.\n\n**Основной стек**: Django, DRF, FastAPI, PostgreSQL, Redis, Celery.\n\n**Ключевой проект** — мультитенантная платформа для 400+ лендингов:\n- Архитектура с изоляцией данных клиентов\n- Интеграции с AmoCRM, CallTouch, Telegram\n- Оптимизация производительности (снизил время ответа на 40%)\n\n**Дополнительный опыт**:\n- Frontend: Vue.js, базовый React\n- DevOps: Docker, CI/CD, Linux\n- Работа в agile-команде\n\nСейчас ищу позицию **Middle/Senior Python Developer**, где смогу применить опыт в микросервисной архитектуре."
        },
        {
            "id": 5,
            "question": "Что такое ORM и какие преимущества Django ORM?",
            "category": "django",
            "answer": "**ORM (Object-Relational Mapping)** — технология, позволяющая работать с БД через объекты Python вместо SQL.\n\n**Преимущества Django ORM**:\n1. **Абстракция от SQL** — код не зависит от типа БД\n2. **Миграции** — автоматическое управление схемой\n3. **QuerySet API** — цепочки вызовов, ленивые запросы\n4. **Защита от SQL-инъекций** — автоматическое экранирование\n\n**Оптимизация запросов**:\n- `select_related()` — JOIN для ForeignKey\n- `prefetch_related()` — отдельные запросы для M2M\n- `only()` / `defer()` — выборочная загрузка полей\n\n**Недостатки**:\n- Сложные запросы лучше писать на raw SQL\n- N+1 проблема при неправильном использовании\n\nВ проектах комбинирую ORM для CRUD и raw SQL для аналитики."
        },
        {
            "id": 6,
            "question": "Как решить N+1 проблему в Django?",
            "category": "django",
            "answer": "**N+1 проблема** — когда для N объектов выполняется N дополнительных запросов к связанным данным.\n\n**Решения в Django**:\n\n1. **select_related()** — для ForeignKey/OneToOne:\n```python\nArticle.objects.select_related('author', 'category')\n```\n\n2. **prefetch_related()** — для ManyToMany/reverse FK:\n```python\nAuthor.objects.prefetch_related('articles')\n```\n\n3. **Prefetch с фильтрацией**:\n```python\nPrefetch('articles', queryset=Article.objects.filter(published=True))\n```\n\n**Как обнаружить**:\n- Django Debug Toolbar — показывает все SQL запросы\n- `connection.queries` — список запросов\n- `assertNumQueries` — в тестах\n\nВ проекте снизил количество запросов с 400+ до 3 на странице списка заказов."
        },
        {
            "id": 7,
            "question": "Что такое REST API и принципы RESTful?",
            "category": "api",
            "answer": "**REST (Representational State Transfer)** — архитектурный стиль для построения API.\n\n**Принципы RESTful**:\n1. **Stateless** — сервер не хранит состояние клиента\n2. **Ресурсы** — URL представляют сущности (`/users/`, `/orders/1/`)\n3. **HTTP методы** — семантика действий (GET, POST, PUT, DELETE)\n4. **Единообразный интерфейс** — стандартные коды ответов\n\n**Лучшие практики**:\n- Версионирование: `/api/v1/users/`\n- Пагинация: `?page=1&limit=20`\n- Фильтрация: `?status=active&sort=-created_at`\n- HATEOAS: ссылки на связанные ресурсы\n\n**В Django REST Framework** использую:\n- ViewSets для CRUD\n- Serializers для валидации\n- Permissions для авторизации\n- Throttling для rate limiting"
        },
        {
            "id": 8,
            "question": "Расскажите о сложной задаче которую вы решили",
            "category": "soft_skills",
            "answer": "**Ситуация**: На проекте мультитенантной платформы возникла проблема — при 400+ клиентах система стала тормозить, время ответа выросло до 5 секунд.\n\n**Задача**: Оптимизировать производительность без рефакторинга всей архитектуры.\n\n**Действия**:\n1. Профилировал запросы через Django Debug Toolbar — нашёл N+1 проблемы\n2. Добавил `select_related`/`prefetch_related` в критичных местах\n3. Внедрил Redis кэширование для часто запрашиваемых данных\n4. Настроил индексы в PostgreSQL по результатам EXPLAIN ANALYZE\n5. Добавил мониторинг через Sentry Performance\n\n**Результат**: Время ответа снизилось с 5 до 0.3 секунд (в 16 раз). Нагрузка на БД упала на 60%. Клиенты перестали жаловаться на тормоза."
        },
        {
            "id": 9,
            "question": "Что такое ACID в базах данных?",
            "category": "database",
            "answer": "**ACID** — набор свойств транзакций, гарантирующих надёжность данных.\n\n**Расшифровка**:\n- **Atomicity (Атомарность)** — транзакция выполняется полностью или откатывается\n- **Consistency (Согласованность)** — данные переходят из одного валидного состояния в другое\n- **Isolation (Изолированность)** — параллельные транзакции не влияют друг на друга\n- **Durability (Долговечность)** — закоммиченные данные не теряются\n\n**В Django**:\n```python\nfrom django.db import transaction\n\nwith transaction.atomic():\n    order.status = 'paid'\n    order.save()\n    Payment.objects.create(order=order, amount=100)\n```\n\n**Уровни изоляции в PostgreSQL**:\n- Read Committed (default)\n- Repeatable Read\n- Serializable"
        },
        {
            "id": 10,
            "question": "Как работает индексирование в PostgreSQL?",
            "category": "database",
            "answer": "**Индекс** — структура данных для ускорения поиска, аналог оглавления в книге.\n\n**Типы индексов в PostgreSQL**:\n1. **B-tree** (default) — для сравнений `=`, `<`, `>`, `BETWEEN`\n2. **Hash** — только для `=`, быстрее B-tree\n3. **GiST** — для геоданных, полнотекстового поиска\n4. **GIN** — для массивов, JSONB, полнотекстовый поиск\n\n**Когда создавать индекс**:\n- Частые WHERE по колонке\n- JOIN по колонке\n- ORDER BY\n\n**Когда НЕ создавать**:\n- Маленькие таблицы (<1000 строк)\n- Колонки с низкой кардинальностью (bool)\n- Часто обновляемые колонки\n\n**Анализ**:\n```sql\nEXPLAIN ANALYZE SELECT * FROM users WHERE email = 'test@test.com';\n```"
        },
        {
            "id": 11,
            "question": "Чем отличается async/await от threading?",
            "category": "python_core",
            "answer": "**Threading** — параллельное выполнение в отдельных потоках ОС.\n**Async/await** — кооперативная многозадачность в одном потоке.\n\n**Ключевые отличия**:\n\n| Аспект | Threading | Async |\n|--------|-----------|-------|\n| Переключение | ОС решает | Явное (await) |\n| GIL | Блокирует CPU-bound | Не влияет |\n| Overhead | Высокий (потоки ОС) | Низкий (корутины) |\n| Количество | Сотни | Тысячи |\n\n**Когда использовать**:\n- `asyncio` — много I/O операций (HTTP, DB, файлы)\n- `threading` — CPU-bound с C-расширениями\n- `multiprocessing` — CPU-bound чистый Python\n\n**В FastAPI** использую async для:\n- Запросов к внешним API\n- Работы с БД через async драйверы\n- WebSocket соединений"
        },
        {
            "id": 12,
            "question": "Что такое Docker и зачем он нужен?",
            "category": "devops",
            "answer": "**Docker** — платформа для контейнеризации приложений.\n\n**Преимущества**:\n1. **Изоляция** — приложение работает одинаково везде\n2. **Воспроизводимость** — точная копия окружения\n3. **Масштабирование** — легко запустить N копий\n4. **CI/CD** — единый артефакт для всех этапов\n\n**Основные команды**:\n```bash\ndocker build -t myapp .\ndocker run -p 8000:8000 myapp\ndocker-compose up -d\n```\n\n**Docker Compose** — для multi-container приложений:\n```yaml\nservices:\n  web:\n    build: .\n    ports: [\"8000:8000\"]\n  db:\n    image: postgres:15\n  redis:\n    image: redis:7\n```\n\nВ проектах использую Docker для локальной разработки и production деплоя."
        },
        {
            "id": 13,
            "question": "Как вы работаете в команде?",
            "category": "soft_skills",
            "answer": "**Мой подход к командной работе**:\n\n**Коммуникация**:\n- Ежедневные стендапы — синхронизация задач\n- Code review — даю конструктивный фидбек, учусь у коллег\n- Документирую решения в Confluence/Notion\n\n**Процессы**:\n- Работаю по Scrum/Kanban в зависимости от проекта\n- Декомпозирую задачи в JIRA до 1-2 дней\n- Придерживаюсь Git Flow (feature branches, PR)\n\n**Конфликты**:\n- Фокус на проблеме, не на личностях\n- Ищу компромисс, основанный на данных\n- Эскалирую если не можем договориться\n\n**Пример**: На прошлом проекте был спор о выборе ORM. Провёл бенчмарки, представил данные команде — приняли совместное решение."
        },
        {
            "id": 14,
            "question": "Что такое миграции в Django?",
            "category": "django",
            "answer": "**Миграции** — система версионирования схемы БД в Django.\n\n**Как работают**:\n1. Изменяете модели в `models.py`\n2. `python manage.py makemigrations` — создаёт файл миграции\n3. `python manage.py migrate` — применяет к БД\n\n**Команды**:\n```bash\nmakemigrations        # Создать миграцию\nmigrate               # Применить миграции\nshowmigrations        # Список миграций\nmigrate app 0003      # Откат до версии 0003\nsqlmigrate app 0004   # Показать SQL\n```\n\n**Лучшие практики**:\n- Не редактируйте применённые миграции\n- Проверяйте миграции перед коммитом\n- Для больших таблиц — `RunSQL` вместо ORM\n- Атомарные миграции с `atomic=False` для PostgreSQL\n\nВ production всегда делаю бэкап перед миграцией."
        },
        {
            "id": 15,
            "question": "Почему вы хотите работать в нашей компании?",
            "category": "soft_skills",
            "answer": "**Интерес к компании** основан на нескольких факторах:\n\n**Технологии**:\n- Ваш стек (Python/Django/PostgreSQL) соответствует моему опыту\n- Интересные технические челленджи (highload/микросервисы)\n- Возможность работать с современными инструментами\n\n**Продукт**:\n- [Адаптировать под компанию] Ваш продукт решает реальную проблему\n- Вижу потенциал для масштабирования\n- Хочу быть частью роста\n\n**Команда и культура**:\n- Ценю прозрачность и открытость\n- Важна возможность влиять на архитектурные решения\n- Интересует менторство и рост до Senior\n\n**Моя ценность**:\n- Опыт оптимизации highload систем\n- Навыки интеграции с внешними сервисами\n- Готовность брать ответственность за результат"
        },
        {
            "id": 16,
            "question": "Что такое контекстный менеджер в Python?",
            "category": "python_core",
            "answer": "**Контекстный менеджер** — объект для управления ресурсами через `with` statement.\n\n**Как работает**:\n```python\nwith open('file.txt') as f:\n    data = f.read()\n# Файл автоматически закрыт\n```\n\n**Создание своего**:\n\n1. **Через класс**:\n```python\nclass Timer:\n    def __enter__(self):\n        self.start = time.time()\n        return self\n    def __exit__(self, *args):\n        print(f'Elapsed: {time.time() - self.start}')\n```\n\n2. **Через декоратор**:\n```python\nfrom contextlib import contextmanager\n\n@contextmanager\ndef timer():\n    start = time.time()\n    yield\n    print(f'Elapsed: {time.time() - start}')\n```\n\n**Применение**:\n- Работа с файлами, БД, сетью\n- Блокировки (threading.Lock)\n- Транзакции (transaction.atomic)"
        },
        {
            "id": 17,
            "question": "Что такое Redis и для чего используется?",
            "category": "database",
            "answer": "**Redis** — in-memory key-value хранилище с поддержкой структур данных.\n\n**Основные use cases**:\n\n1. **Кэширование**:\n```python\ncache.set('user:1', user_data, timeout=300)\nuser = cache.get('user:1')\n```\n\n2. **Сессии**:\n- Быстрее чем БД\n- Автоматическое истечение\n\n3. **Очереди задач** (Celery):\n```python\n@celery_app.task\ndef send_email(user_id):\n    ...\n```\n\n4. **Pub/Sub**:\n- Real-time уведомления\n- WebSocket broadcasting\n\n5. **Rate limiting**:\n```python\nif redis.incr(f'rate:{ip}') > 100:\n    raise TooManyRequests()\nredis.expire(f'rate:{ip}', 60)\n```\n\n**Структуры данных**: String, List, Set, Hash, Sorted Set, Stream.\n\nВ проектах использую для кэша Django и очередей Celery."
        },
        {
            "id": 18,
            "question": "Какие ваши сильные и слабые стороны?",
            "category": "soft_skills",
            "answer": "**Сильные стороны**:\n\n1. **Системное мышление** — вижу картину целиком, а не только свою задачу\n2. **Оптимизация** — нахожу bottleneck и решаю проблемы производительности\n3. **Самообучение** — быстро осваиваю новые технологии\n4. **Документирование** — пишу понятный код и документацию\n\n**Слабые стороны** (над чем работаю):\n\n1. **Перфекционизм** — иногда трачу много времени на идеальное решение\n   - Решение: ставлю таймбоксы, применяю принцип 80/20\n\n2. **Делегирование** — предпочитаю делать сам\n   - Решение: учусь доверять коллегам, провожу code review\n\n3. **Публичные выступления** — волнуюсь перед большой аудиторией\n   - Решение: практикуюсь на внутренних митингах"
        },
        {
            "id": 19,
            "question": "Что такое Celery и как работает?",
            "category": "python_core",
            "answer": "**Celery** — асинхронная очередь задач для Python.\n\n**Архитектура**:\n```\nПриложение → Брокер (Redis/RabbitMQ) → Worker → Результат\n```\n\n**Основные концепции**:\n\n1. **Задача (Task)**:\n```python\n@app.task\ndef send_email(user_id):\n    user = User.objects.get(id=user_id)\n    send_mail(user.email, 'Hello!')\n```\n\n2. **Вызов задачи**:\n```python\nsend_email.delay(user_id)  # Асинхронно\nsend_email.apply_async(args=[user_id], countdown=60)  # Через 60 сек\n```\n\n3. **Периодические задачи** (Celery Beat):\n```python\nCELERY_BEAT_SCHEDULE = {\n    'cleanup': {\n        'task': 'app.tasks.cleanup',\n        'schedule': crontab(hour=3, minute=0),\n    }\n}\n```\n\n**Применение**:\n- Email/SMS рассылки\n- Обработка файлов\n- Периодические задачи\n- Долгие вычисления"
        },
        {
            "id": 20,
            "question": "Как вы оцениваете сроки задач?",
            "category": "soft_skills",
            "answer": "**Мой подход к оценке**:\n\n1. **Декомпозиция**:\n   - Разбиваю задачу на подзадачи 2-4 часа\n   - Оцениваю каждую отдельно\n   - Суммирую с буфером 20-30%\n\n2. **Учёт рисков**:\n   - Знакомая технология: оценка × 1.2\n   - Новая технология: оценка × 1.5\n   - Интеграция с внешним API: + 50% на отладку\n\n3. **Исторические данные**:\n   - Смотрю похожие задачи в JIRA\n   - Учитываю прошлые ошибки оценки\n\n4. **Коммуникация**:\n   - Даю диапазон: 2-3 дня, не точную цифру\n   - Сразу сообщаю если вижу риск срыва\n   - Декомпозирую большие задачи вместе с PM\n\n**Пример**: Задачу \"Интеграция с платёжной системой\" оценил в 5 дней, сделал за 4 — заложил буфер на неожиданности в API."
        }
    ]
}