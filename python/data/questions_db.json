{
    "version": "1.0",
    "description": "База готовых вопросов для технических собеседований Python/Fullstack",
    "questions": [
        {
            "id": 1,
            "question": "Что такое декоратор в Python?",
            "category": "python_core",
            "answer": "**Декоратор** — это паттерн проектирования, позволяющий расширить поведение функции без изменения её кода.\n\n**Как работает**:\n1. Декоратор — функция, которая принимает функцию и возвращает новую функцию\n2. Использует замыкание (closure) для сохранения ссылки на оригинал\n3. Синтаксис `@decorator` — сахар для `func = decorator(func)`\n\n**Примеры использования**:\n- `@login_required` — проверка авторизации\n- `@cache` — кэширование результатов\n- `@transaction.atomic` — атомарные транзакции в Django\n\nВ своих проектах часто пишу декораторы для логирования, валидации и измерения времени выполнения."
        },
        {
            "id": 2,
            "question": "Чем отличается list от tuple?",
            "category": "python_core",
            "answer": "**Главное отличие**: list — изменяемый (mutable), tuple — неизменяемый (immutable).\n\n**Практические различия**:\n- **Производительность**: tuple быстрее (меньше overhead)\n- **Память**: tuple занимает меньше памяти\n- **Хэшируемость**: tuple можно использовать как ключ dict, list — нельзя\n- **Безопасность**: tuple защищает от случайных изменений\n\n**Когда использовать**:\n- `tuple` — для фиксированных данных (координаты, конфигурация)\n- `list` — для динамических коллекций (результаты запроса, буферы)\n\nВ Django часто использую tuple для `INSTALLED_APPS`, `MIDDLEWARE` — они не должны меняться в runtime."
        },
        {
            "id": 3,
            "question": "Что такое GIL и как он влияет на многопоточность?",
            "category": "python_core",
            "answer": "**GIL (Global Interpreter Lock)** — глобальная блокировка, позволяющая выполнять только один поток Python-кода одновременно.\n\n**Влияние на производительность**:\n- **CPU-bound задачи**: GIL блокирует параллелизм, используйте `multiprocessing`\n- **I/O-bound задачи**: GIL освобождается при I/O, `threading` работает эффективно\n\n**Обходные решения**:\n1. `multiprocessing` — отдельные процессы без GIL\n2. `asyncio` — асинхронность для I/O операций\n3. C-расширения — NumPy, Pandas освобождают GIL\n4. Альтернативные интерпретаторы — PyPy, Jython\n\nВ веб-приложениях GIL редко проблема — большинство операций I/O-bound (БД, HTTP запросы)."
        },
        {
            "id": 4,
            "question": "Расскажите о себе",
            "category": "soft_skills",
            "answer": "Я **Python Backend Developer** с опытом более 3 лет. Специализируюсь на разработке высоконагруженных веб-приложений.\n\n**Основной стек**: Django, DRF, FastAPI, PostgreSQL, Redis, Celery.\n\n**Ключевой проект** — мультитенантная платформа для 400+ лендингов:\n- Архитектура с изоляцией данных клиентов\n- Интеграции с AmoCRM, CallTouch, Telegram\n- Оптимизация производительности (снизил время ответа на 40%)\n\n**Дополнительный опыт**:\n- Frontend: Vue.js, базовый React\n- DevOps: Docker, CI/CD, Linux\n- Работа в agile-команде\n\nСейчас ищу позицию **Middle/Senior Python Developer**, где смогу применить опыт в микросервисной архитектуре."
        },
        {
            "id": 5,
            "question": "Что такое ORM и какие преимущества Django ORM?",
            "category": "django",
            "answer": "**ORM (Object-Relational Mapping)** — технология, позволяющая работать с БД через объекты Python вместо SQL.\n\n**Преимущества Django ORM**:\n1. **Абстракция от SQL** — код не зависит от типа БД\n2. **Миграции** — автоматическое управление схемой\n3. **QuerySet API** — цепочки вызовов, ленивые запросы\n4. **Защита от SQL-инъекций** — автоматическое экранирование\n\n**Оптимизация запросов**:\n- `select_related()` — JOIN для ForeignKey\n- `prefetch_related()` — отдельные запросы для M2M\n- `only()` / `defer()` — выборочная загрузка полей\n\n**Недостатки**:\n- Сложные запросы лучше писать на raw SQL\n- N+1 проблема при неправильном использовании\n\nВ проектах комбинирую ORM для CRUD и raw SQL для аналитики."
        },
        {
            "id": 6,
            "question": "Как решить N+1 проблему в Django?",
            "category": "django",
            "answer": "**N+1 проблема** — когда для N объектов выполняется N дополнительных запросов к связанным данным.\n\n**Решения в Django**:\n\n1. **select_related()** — для ForeignKey/OneToOne:\n```python\nArticle.objects.select_related('author', 'category')\n```\n\n2. **prefetch_related()** — для ManyToMany/reverse FK:\n```python\nAuthor.objects.prefetch_related('articles')\n```\n\n3. **Prefetch с фильтрацией**:\n```python\nPrefetch('articles', queryset=Article.objects.filter(published=True))\n```\n\n**Как обнаружить**:\n- Django Debug Toolbar — показывает все SQL запросы\n- `connection.queries` — список запросов\n- `assertNumQueries` — в тестах\n\nВ проекте снизил количество запросов с 400+ до 3 на странице списка заказов."
        },
        {
            "id": 7,
            "question": "Что такое REST API и принципы RESTful?",
            "category": "api",
            "answer": "**REST (Representational State Transfer)** — архитектурный стиль для построения API.\n\n**Принципы RESTful**:\n1. **Stateless** — сервер не хранит состояние клиента\n2. **Ресурсы** — URL представляют сущности (`/users/`, `/orders/1/`)\n3. **HTTP методы** — семантика действий (GET, POST, PUT, DELETE)\n4. **Единообразный интерфейс** — стандартные коды ответов\n\n**Лучшие практики**:\n- Версионирование: `/api/v1/users/`\n- Пагинация: `?page=1&limit=20`\n- Фильтрация: `?status=active&sort=-created_at`\n- HATEOAS: ссылки на связанные ресурсы\n\n**В Django REST Framework** использую:\n- ViewSets для CRUD\n- Serializers для валидации\n- Permissions для авторизации\n- Throttling для rate limiting"
        },
        {
            "id": 8,
            "question": "Расскажите о сложной задаче которую вы решили",
            "category": "soft_skills",
            "answer": "**Ситуация**: На проекте мультитенантной платформы возникла проблема — при 400+ клиентах система стала тормозить, время ответа выросло до 5 секунд.\n\n**Задача**: Оптимизировать производительность без рефакторинга всей архитектуры.\n\n**Действия**:\n1. Профилировал запросы через Django Debug Toolbar — нашёл N+1 проблемы\n2. Добавил `select_related`/`prefetch_related` в критичных местах\n3. Внедрил Redis кэширование для часто запрашиваемых данных\n4. Настроил индексы в PostgreSQL по результатам EXPLAIN ANALYZE\n5. Добавил мониторинг через Sentry Performance\n\n**Результат**: Время ответа снизилось с 5 до 0.3 секунд (в 16 раз). Нагрузка на БД упала на 60%. Клиенты перестали жаловаться на тормоза."
        },
        {
            "id": 9,
            "question": "Что такое ACID в базах данных?",
            "category": "database",
            "answer": "**ACID** — набор свойств транзакций, гарантирующих надёжность данных.\n\n**Расшифровка**:\n- **Atomicity (Атомарность)** — транзакция выполняется полностью или откатывается\n- **Consistency (Согласованность)** — данные переходят из одного валидного состояния в другое\n- **Isolation (Изолированность)** — параллельные транзакции не влияют друг на друга\n- **Durability (Долговечность)** — закоммиченные данные не теряются\n\n**В Django**:\n```python\nfrom django.db import transaction\n\nwith transaction.atomic():\n    order.status = 'paid'\n    order.save()\n    Payment.objects.create(order=order, amount=100)\n```\n\n**Уровни изоляции в PostgreSQL**:\n- Read Committed (default)\n- Repeatable Read\n- Serializable"
        },
        {
            "id": 10,
            "question": "Как работает индексирование в PostgreSQL?",
            "category": "database",
            "answer": "**Индекс** — структура данных для ускорения поиска, аналог оглавления в книге.\n\n**Типы индексов в PostgreSQL**:\n1. **B-tree** (default) — для сравнений `=`, `<`, `>`, `BETWEEN`\n2. **Hash** — только для `=`, быстрее B-tree\n3. **GiST** — для геоданных, полнотекстового поиска\n4. **GIN** — для массивов, JSONB, полнотекстовый поиск\n\n**Когда создавать индекс**:\n- Частые WHERE по колонке\n- JOIN по колонке\n- ORDER BY\n\n**Когда НЕ создавать**:\n- Маленькие таблицы (<1000 строк)\n- Колонки с низкой кардинальностью (bool)\n- Часто обновляемые колонки\n\n**Анализ**:\n```sql\nEXPLAIN ANALYZE SELECT * FROM users WHERE email = 'test@test.com';\n```"
        },
        {
            "id": 11,
            "question": "Чем отличается async/await от threading?",
            "category": "python_core",
            "answer": "**Threading** — параллельное выполнение в отдельных потоках ОС.\n**Async/await** — кооперативная многозадачность в одном потоке.\n\n**Ключевые отличия**:\n\n| Аспект | Threading | Async |\n|--------|-----------|-------|\n| Переключение | ОС решает | Явное (await) |\n| GIL | Блокирует CPU-bound | Не влияет |\n| Overhead | Высокий (потоки ОС) | Низкий (корутины) |\n| Количество | Сотни | Тысячи |\n\n**Когда использовать**:\n- `asyncio` — много I/O операций (HTTP, DB, файлы)\n- `threading` — CPU-bound с C-расширениями\n- `multiprocessing` — CPU-bound чистый Python\n\n**В FastAPI** использую async для:\n- Запросов к внешним API\n- Работы с БД через async драйверы\n- WebSocket соединений"
        },
        {
            "id": 12,
            "question": "Что такое Docker и зачем он нужен?",
            "category": "devops",
            "answer": "**Docker** — платформа для контейнеризации приложений.\n\n**Преимущества**:\n1. **Изоляция** — приложение работает одинаково везде\n2. **Воспроизводимость** — точная копия окружения\n3. **Масштабирование** — легко запустить N копий\n4. **CI/CD** — единый артефакт для всех этапов\n\n**Основные команды**:\n```bash\ndocker build -t myapp .\ndocker run -p 8000:8000 myapp\ndocker-compose up -d\n```\n\n**Docker Compose** — для multi-container приложений:\n```yaml\nservices:\n  web:\n    build: .\n    ports: [\"8000:8000\"]\n  db:\n    image: postgres:15\n  redis:\n    image: redis:7\n```\n\nВ проектах использую Docker для локальной разработки и production деплоя."
        },
        {
            "id": 13,
            "question": "Как вы работаете в команде?",
            "category": "soft_skills",
            "answer": "**Мой подход к командной работе**:\n\n**Коммуникация**:\n- Ежедневные стендапы — синхронизация задач\n- Code review — даю конструктивный фидбек, учусь у коллег\n- Документирую решения в Confluence/Notion\n\n**Процессы**:\n- Работаю по Scrum/Kanban в зависимости от проекта\n- Декомпозирую задачи в JIRA до 1-2 дней\n- Придерживаюсь Git Flow (feature branches, PR)\n\n**Конфликты**:\n- Фокус на проблеме, не на личностях\n- Ищу компромисс, основанный на данных\n- Эскалирую если не можем договориться\n\n**Пример**: На прошлом проекте был спор о выборе ORM. Провёл бенчмарки, представил данные команде — приняли совместное решение."
        },
        {
            "id": 14,
            "question": "Что такое миграции в Django?",
            "category": "django",
            "answer": "**Миграции** — система версионирования схемы БД в Django.\n\n**Как работают**:\n1. Изменяете модели в `models.py`\n2. `python manage.py makemigrations` — создаёт файл миграции\n3. `python manage.py migrate` — применяет к БД\n\n**Команды**:\n```bash\nmakemigrations        # Создать миграцию\nmigrate               # Применить миграции\nshowmigrations        # Список миграций\nmigrate app 0003      # Откат до версии 0003\nsqlmigrate app 0004   # Показать SQL\n```\n\n**Лучшие практики**:\n- Не редактируйте применённые миграции\n- Проверяйте миграции перед коммитом\n- Для больших таблиц — `RunSQL` вместо ORM\n- Атомарные миграции с `atomic=False` для PostgreSQL\n\nВ production всегда делаю бэкап перед миграцией."
        },
        {
            "id": 15,
            "question": "Почему вы хотите работать в нашей компании?",
            "category": "soft_skills",
            "answer": "**Интерес к компании** основан на нескольких факторах:\n\n**Технологии**:\n- Ваш стек (Python/Django/PostgreSQL) соответствует моему опыту\n- Интересные технические челленджи (highload/микросервисы)\n- Возможность работать с современными инструментами\n\n**Продукт**:\n- [Адаптировать под компанию] Ваш продукт решает реальную проблему\n- Вижу потенциал для масштабирования\n- Хочу быть частью роста\n\n**Команда и культура**:\n- Ценю прозрачность и открытость\n- Важна возможность влиять на архитектурные решения\n- Интересует менторство и рост до Senior\n\n**Моя ценность**:\n- Опыт оптимизации highload систем\n- Навыки интеграции с внешними сервисами\n- Готовность брать ответственность за результат"
        },
        {
            "id": 16,
            "question": "Что такое контекстный менеджер в Python?",
            "category": "python_core",
            "answer": "**Контекстный менеджер** — объект для управления ресурсами через `with` statement.\n\n**Как работает**:\n```python\nwith open('file.txt') as f:\n    data = f.read()\n# Файл автоматически закрыт\n```\n\n**Создание своего**:\n\n1. **Через класс**:\n```python\nclass Timer:\n    def __enter__(self):\n        self.start = time.time()\n        return self\n    def __exit__(self, *args):\n        print(f'Elapsed: {time.time() - self.start}')\n```\n\n2. **Через декоратор**:\n```python\nfrom contextlib import contextmanager\n\n@contextmanager\ndef timer():\n    start = time.time()\n    yield\n    print(f'Elapsed: {time.time() - start}')\n```\n\n**Применение**:\n- Работа с файлами, БД, сетью\n- Блокировки (threading.Lock)\n- Транзакции (transaction.atomic)"
        },
        {
            "id": 17,
            "question": "Что такое Redis и для чего используется?",
            "category": "database",
            "answer": "**Redis** — in-memory key-value хранилище с поддержкой структур данных.\n\n**Основные use cases**:\n\n1. **Кэширование**:\n```python\ncache.set('user:1', user_data, timeout=300)\nuser = cache.get('user:1')\n```\n\n2. **Сессии**:\n- Быстрее чем БД\n- Автоматическое истечение\n\n3. **Очереди задач** (Celery):\n```python\n@celery_app.task\ndef send_email(user_id):\n    ...\n```\n\n4. **Pub/Sub**:\n- Real-time уведомления\n- WebSocket broadcasting\n\n5. **Rate limiting**:\n```python\nif redis.incr(f'rate:{ip}') > 100:\n    raise TooManyRequests()\nredis.expire(f'rate:{ip}', 60)\n```\n\n**Структуры данных**: String, List, Set, Hash, Sorted Set, Stream.\n\nВ проектах использую для кэша Django и очередей Celery."
        },
        {
            "id": 18,
            "question": "Какие ваши сильные и слабые стороны?",
            "category": "soft_skills",
            "answer": "**Сильные стороны**:\n\n1. **Системное мышление** — вижу картину целиком, а не только свою задачу\n2. **Оптимизация** — нахожу bottleneck и решаю проблемы производительности\n3. **Самообучение** — быстро осваиваю новые технологии\n4. **Документирование** — пишу понятный код и документацию\n\n**Слабые стороны** (над чем работаю):\n\n1. **Перфекционизм** — иногда трачу много времени на идеальное решение\n   - Решение: ставлю таймбоксы, применяю принцип 80/20\n\n2. **Делегирование** — предпочитаю делать сам\n   - Решение: учусь доверять коллегам, провожу code review\n\n3. **Публичные выступления** — волнуюсь перед большой аудиторией\n   - Решение: практикуюсь на внутренних митингах"
        },
        {
            "id": 19,
            "question": "Что такое Celery и как работает?",
            "category": "python_core",
            "answer": "**Celery** — асинхронная очередь задач для Python.\n\n**Архитектура**:\n```\nПриложение → Брокер (Redis/RabbitMQ) → Worker → Результат\n```\n\n**Основные концепции**:\n\n1. **Задача (Task)**:\n```python\n@app.task\ndef send_email(user_id):\n    user = User.objects.get(id=user_id)\n    send_mail(user.email, 'Hello!')\n```\n\n2. **Вызов задачи**:\n```python\nsend_email.delay(user_id)  # Асинхронно\nsend_email.apply_async(args=[user_id], countdown=60)  # Через 60 сек\n```\n\n3. **Периодические задачи** (Celery Beat):\n```python\nCELERY_BEAT_SCHEDULE = {\n    'cleanup': {\n        'task': 'app.tasks.cleanup',\n        'schedule': crontab(hour=3, minute=0),\n    }\n}\n```\n\n**Применение**:\n- Email/SMS рассылки\n- Обработка файлов\n- Периодические задачи\n- Долгие вычисления"
        },
        {
            "id": 20,
            "question": "Как вы оцениваете сроки задач?",
            "category": "soft_skills",
            "answer": "**Мой подход к оценке**:\n\n1. **Декомпозиция**:\n   - Разбиваю задачу на подзадачи 2-4 часа\n   - Оцениваю каждую отдельно\n   - Суммирую с буфером 20-30%\n\n2. **Учёт рисков**:\n   - Знакомая технология: оценка × 1.2\n   - Новая технология: оценка × 1.5\n   - Интеграция с внешним API: + 50% на отладку\n\n3. **Исторические данные**:\n   - Смотрю похожие задачи в JIRA\n   - Учитываю прошлые ошибки оценки\n\n4. **Коммуникация**:\n   - Даю диапазон: 2-3 дня, не точную цифру\n   - Сразу сообщаю если вижу риск срыва\n   - Декомпозирую большие задачи вместе с PM\n\n**Пример**: Задачу \"Интеграция с платёжной системой\" оценил в 5 дней, сделал за 4 — заложил буфер на неожиданности в API."
        },
        {
            "id": 21,
            "question": "В чем разница между `__new__` и `__init__`?",
            "category": "python_core",
            "answer": "**`__new__`** — статический метод, отвечающий за **создание** экземпляра класса. Вызывается первым.\n- Принимает `cls`.\n- Должен вернуть экземпляр класса (обычно через `super().__new__(cls)`).\n- Используется для наследования от неизменяемых типов (str, int, tuple) или в метаклассах/синглтонах.\n\n**`__init__`** — метод **инициализации** уже созданного объекта. Вызывается после `__new__`.\n- Принимает `self`.\n- Ничего не возвращает.\n- Используется для установки атрибутов объекта."
        },
        {
            "id": 22,
            "question": "Что такое MRO? Как он работает?",
            "category": "python_core",
            "answer": "**MRO (Method Resolution Order)** — порядок разрешения методов при множественном наследовании.\n\nВ Python 3 используется алгоритм **C3 Linearization**.\n\n**Правила**:\n1. Дети проверяются перед родителями.\n2. Если класс наследуется от нескольких родителей, они проверяются в порядке перечисления.\n3. Порядок должен быть согласованным (непротиворечивым).\n\nПосмотреть MRO можно через `ClassName.mro()` или `ClassName.__mro__`.\nЭто предотвращает проблемы ромбовидного наследования."
        },
        {
            "id": 23,
            "question": "Как работают `args` и `kwargs`?",
            "category": "python_core",
            "answer": "Используются для передачи произвольного количества аргументов в функцию.\n\n- `*args` (arguments) — собирает позиционные аргументы в **tuple**.\n- `**kwargs` (keyword arguments) — собирает именованные аргументы в **dict**.\n\n**Пример**:\n```python\ndef func(*args, **kwargs):\n    print(args)   # (1, 2)\n    print(kwargs) # {'a': 3}\n\nfunc(1, 2, a=3)\n```\n\nТакже используются для распаковки коллекций при вызове функций."
        },
        {
            "id": 24,
            "question": "Что такое итератор и генератор? В чем разница?",
            "category": "python_core",
            "answer": "**Итератор** — объект, поддерживающий протокол итерации (методы `__iter__` и `__next__`). Хранит состояние и выдает элементы по одному.\n\n**Генератор** — функция, использующая `yield` вместо `return`.\n- Автоматически реализует протокол итератора.\n- Ленивое вычисление (память расходуется только на текущий элемент).\n- Удобнее писать, чем создавать класс-итератор.\n\nЛюбой генератор является итератором, но не наоборот."
        },
        {
            "id": 25,
            "question": "Как работает Garbage Collection в Python?",
            "category": "python_core",
            "answer": "Управление памятью в Python основано на двух механизмах:\n\n1. **Подсчет ссылок (Reference Counting)** — основной механизм. Объект удаляется сразу, как только счетчик ссылок на него становится равен 0.\n2. **Garbage Collector (GC)** — вспомогательный механизм для обнаружения и удаления **циклических ссылок**.\n\nGC работает поколениями (0, 1, 2). Объекты, пережившие сборку мусора, перемещаются в старшее поколение, которое сканируется реже."
        },
        {
            "id": 26,
            "question": "Что такое замыкание (closure)?",
            "category": "python_core",
            "answer": "**Замыкание** — это функция, которая запоминает значения переменных из охватывающей области видимости (enclosing scope), даже если эта область уже перестала существовать.\n\n**Пример**:\n```python\ndef outer(x):\n    def inner(y):\n        return x + y\n    return inner\n\nadd_5 = outer(5)\nprint(add_5(10))  # 15\n```\nЗдесь `inner` «замыкает» переменную `x`."
        },
        {
            "id": 27,
            "question": "Что делает ключевое слово `global` и `nonlocal`?",
            "category": "python_core",
            "answer": "- **`global`**: позволяет изменять переменную в глобальной области видимости (module level) изнутри функции.\n- **`nonlocal`**: позволяет изменять переменную в ближайшей охватывающей (не глобальной) области видимости (enclosing scope). Используется во вложенных функциях (замыканиях)."
        },
        {
            "id": 28,
            "question": "Что такое менеджер контекста `async with`?",
            "category": "python_core",
            "answer": "Асинхронный аналог обычного контекстного менеджера.\nИспользует методы `__aenter__` и `__aexit__`, которые должны быть `async def` (корутинами).\n\n**Пример** (соединение с БД):\n```python\nasync with aiohttp.ClientSession() as session:\n    async with session.get(url) as resp:\n        data = await resp.text()\n```\nПозволяет выполнять асинхронные операции (await) при входе и выходе из контекста."
        },
        {
            "id": 29,
            "question": "Разница между `is` и `==`?",
            "category": "python_core",
            "answer": "- **`==`** сравнивает **значения** объектов (вызывает `__eq__`).\n- **`is`** сравнивает **идентичность** объектов (адреса в памяти, `id()`).\n\n**Пример**:\n```python\na = [1, 2]\nb = [1, 2]\nprint(a == b)  # True (значения равны)\nprint(a is b)  # False (разные объекты в памяти)\n```\n`None` всегда сравнивают через `is`."
        },
        {
            "id": 30,
            "question": "Что такое `__slots__` и зачем использовать?",
            "category": "python_core",
            "answer": "**`__slots__`** — атрибут класса, ограничивающий набор атрибутов экземпляра.\n\n**Преимущества**:\n1. **Экономия памяти**: вместо `__dict__` для каждого экземпляра используется фиксированный массив ссылок.\n2. **Скорость**: доступ к атрибутам немного быстрее.\n3. **Запрет** на создание новых атрибутов в runtime.\n\nИспользуется при создании миллионов однотипных объектов для оптимизации."
        },
        {
            "id": 31,
            "question": "Что такое глубокое и поверхностное копирование?",
            "category": "python_core",
            "answer": "- **Shallow copy** (`copy.copy()`): создает новый объект, но вставляет в него **ссылки** на вложенные объекты. Изменение вложенных мутабельных объектов отразится на оригинале.\n- **Deep copy** (`copy.deepcopy()`): рекурсивно создает копии всех вложенных объектов. Полная независимость от оригинала.\n\n**Пример**:\n```python\nimport copy\na = [[1], 2]\nb = copy.copy(a)\nb[0].append(3)\n# a станет [[1, 3], 2]\n```"
        },
        {
            "id": 32,
            "question": "В чем особенность изменяемых (mutable) дефолтных аргументов?",
            "category": "python_core",
            "answer": "Дефолтные аргументы вычисляются **один раз** при определении функции, а не при каждом вызове.\n\nЕсли дефолтный аргумент мутабельный (list, dict), он сохраняет состояние между вызовами.\n\n**Плохо**:\n```python\ndef append_to(element, target=[]):\n    target.append(element)\n    return target\n```\n**Хорошо**:\n```python\ndef append_to(element, target=None):\n    if target is None:\n        target = []\n    ...\n```"
        },
        {
            "id": 33,
            "question": "Что такое дескриптор?",
            "category": "python_core",
            "answer": "**Дескриптор** — это объект атрибута класса, который переопределяет поведение доступа к нему через методы `__get__`, `__set__`, `__delete__`.\n\nИспользуется для создания управляемых атрибутов.\n`@property`, методы, `classmethod`, `staticmethod` — это встроенные дескрипторы.\n\nПозволяет реализовать логику валидации, ленивой загрузки или вычислений при обращении к атрибуту."
        },
        {
            "id": 34,
            "question": "Как работают `classmethod` и `staticmethod`?",
            "category": "python_core",
            "answer": "- **`@classmethod`**: принимает первым аргументом класс (`cls`). Имеет доступ к состоянию класса (может менять атрибуты класса, создавать экземпляры).\n- **`@staticmethod`**: не принимает ни `self`, ни `cls`. Просто функция внутри пространства имен класса. Не имеет доступа к состоянию класса или экземпляра.\n\n`classmethod` часто используют для альтернативных конструкторов."
        },
        {
            "id": 35,
            "question": "Что такое метаклассы?",
            "category": "python_core",
            "answer": "**Метакласс** — это «класс для класса». Он определяет, как создается сам класс (а не его экземпляры).\n\nВ Python класс — это объект, экземпляром метакласса `type`.\n\nМетаклассы позволяют:\n- Перехватить создание класса.\n- Изменить атрибуты класса.\n- Реализовать авто-регистрацию классов.\n- Проверить соответствие интерфейсу.\n\nПример: Django ORM модели используют метаклассы для магии с полями."
        },
        {
            "id": 36,
            "question": "Разница между процессами и потоками (глубже)?",
            "category": "python_core",
            "answer": "- **Процесс**: отдельное адресное пространство, свой GIL (в Python), тяжелее создавать, межпроцессное взаимодействие (IPC) сложнее (pipes, queues, sockets).\n- **Поток**: общее адресное пространство процесса, общий GIL, легко создавать, общая память (нужны локи).\n\nВ Python из-за GIL потоки хороши только для I/O-bound. Для CPU-bound нужны процессы (`multiprocessing`), чтобы задействовать несколько ядер."
        },
        {
            "id": 37,
            "question": "Что такое dataclass?",
            "category": "python_core",
            "answer": "**Dataclass** (Python 3.7+) — декоратор `@dataclass`, автоматически генерирующий методы `__init__`, `__repr__`, `__eq__` и другие на основе аннотаций типов.\n\nСокращает боилерплейт для классов, хранящих данные.\n\n```python\n@dataclass\nclass Point:\n    x: int\n    y: int\n```\nПоддерживает `frozen=True` (неизменяемость), дефолтные значения через `field()`."
        },
        {
            "id": 38,
            "question": "Как работает `import` в Python?",
            "category": "python_core",
            "answer": "1. Проверяет `sys.modules` (кэш импортированных модулей).\n2. Если нет — ищет файл модуля по путям в `sys.path`.\n3. Компилирует в байт-код (.pyc), если нужно.\n4. Выполняет код модуля сверху вниз.\n5. Создает объект модуля и помещает в `sys.modules`.\n\nЦиклические импорты возникают, когда модули пытаются импортировать друг друга во время выполнения шага 4."
        },
        {
            "id": 39,
            "question": "Что такое абстрактный базовый класс (ABC)?",
            "category": "python_core",
            "answer": "Класс, который не предназначен для создания экземпляров, а задает интерфейс для наследников.\nИспользует модуль `abc`.\n\nМетоды с декоратором `@abstractmethod` **обязаны** быть переопределены в дочерних классах, иначе создать экземпляр будет нельзя.\n\nОбеспечивает строгую типизацию и контракт интерфейсов."
        },
        {
            "id": 40,
            "question": "Что такое Type Hinting и зачем он нужен?",
            "category": "python_core",
            "answer": "Аннотации типов (PEP 484) не влияют на выполнение кода (игнорируются интерпретатором), но используются для:\n1. Статического анализа (`mypy`) — поиск багов до запуска.\n2. Документации — код читаемее.\n3. IDE автокомплита.\n\nИспользует модуль `typing` (`List`, `Dict`, `Optional`, `Union`, `Callable`). В свежих версиях можно использовать встроенные типы (`list[int]`)."
        },
        {
            "id": 41,
            "question": "Жизненный цикл Django Request/Response?",
            "category": "django",
            "answer": "1. **WebServer (Nginx/Gunicorn)** получает HTTP запрос.\n2. **WSGI/ASGI Handler** инициализирует `request`.\n3. **Middleware** (process_request) — предобработка.\n4. **URL Router** (urls.py) — поиск view.\n5. **Middleware** (process_view).\n6. **View** — бизнес-логика, обращение к БД.\n7. **Template/Serializer** — рендеринг ответа.\n8. **Middleware** (process_response) — постобработка.\n9. Ответ уходит клиенту."
        },
        {
            "id": 42,
            "question": "Что такое Middleware в Django?",
            "category": "django",
            "answer": "Хуки, оборачивающие процесс обработки запроса/ответа.\nРаботают по принципу «луковицы».\n\n**Методы**:\n- `__init__`\n- `__call__` (основной код)\n- `process_view`\n- `process_exception`\n\n**Примеры**:\n- `AuthenticationMiddleware` (добавляет `request.user`)\n- `SessionMiddleware` (работа с сессиями)\n- `CsrfViewMiddleware` (защита)\n- Логирование запросов, CORS."
        },
        {
            "id": 43,
            "question": "Signal vs Direct Call в Django: что выбрать?",
            "category": "django",
            "answer": "**Сигналы** (`post_save`, `pre_delete`) позволяют развязать компоненты (decoupling). Отправитель не знает о получателе.\n\n**Минусы сигналов**:\n- Неявная логика (сложно отлаживать, непонятно откуда прилетело).\n- Синхронны по умолчанию (тормозят сохранение).\n- Могут вызвать рекурсию.\n\n**Лучше прямой вызов (Direct Call)** или переопределение `save()`/Service Layer, если логика жестко связана с моделью. Сигналы — только для сторонних приложений или слабой связности."
        },
        {
            "id": 44,
            "question": "Как оптимизировать Django ORM запросы (кроме select/prefetch)?",
            "category": "django",
            "answer": "1. **`values()` / `values_list()`** — тянуть только нужные поля (возвращает dict/tuple, без создания объектов моделей).\n2. **`exists()`** — проверка наличия вместо `count()` > 0.\n3. **`iterator()`** — для перебора огромных QuerySet (экономит память, не кэширует).\n4. **`bulk_create()` / `bulk_update()`** — массовые вставки/обновления одним запросом.\n5. **Индексы** в БД.\n6. Избегать логики в циклах шаблонов."
        },
        {
            "id": 45,
            "question": "F-объекты и Q-объекты в Django?",
            "category": "django",
            "answer": "- **`Q()`** — для сложных логических условий (OR, NOT, AND).\n  `filter(Q(age__gt=20) | Q(role='admin'))`\n\n- **`F()`** — ссылка на значение поля в базе данных. Позволяет делать операции на уровне БД без вытаскивания данных в Python.\n  `Product.objects.update(price=F('price') * 1.2)` (поднять цену на 20%).\n  Также используется для сравнения полей одной модели между собой."
        },
        {
            "id": 46,
            "question": "Django Channels: зачем и как работает?",
            "category": "django",
            "answer": "Расширяет Django для работы с **WebSockets**, HTTP/2 и другими асинхронными протоколами.\n\nИспользует **ASGI** вместо WSGI.\n**Компоненты**:\n- `Consumers` (аналог View, но для событий).\n- `Channel Layer` (обычно Redis) — для общения между процессами/воркерами.\n\nПозволяет делать чаты, уведомления, real-time обновления в рамках Django-проекта."
        },
        {
            "id": 47,
            "question": "Разница между Serializer и ModelSerializer в DRF?",
            "category": "api",
            "answer": "- **`Serializer`**: Базовый класс. Нужно вручную описывать все поля и методы `create()`/`update()`.\n- **`ModelSerializer`**: Наследник Serializer. Автоматически создает поля на основе модели Django, реализует базовые `create()`/`update()`.\n\nИспользуйте `ModelSerializer` для CRUD операций над моделями, `Serializer` — для валидации произвольных данных (входные параметры, отчеты)."
        },
        {
            "id": 48,
            "question": "Authentication vs Permission в DRF?",
            "category": "api",
            "answer": "- **Authentication (Кто ты?)**: Определяет пользователя (`request.user`). JWT, Basic, Session, Token. Если не узнал — `401 Unauthorized`.\n- **Permission (Можно ли тебе?)**: Проверяет права доступа уже аутентифицированного пользователя. `IsAuthenticated`, `IsAdminUser`. Если нельзя — `403 Forbidden`.\n\nСначала отрабатывает Auth, потом Perm."
        },
        {
            "id": 49,
            "question": "Что такое ViewSet и Router в DRF?",
            "category": "api",
            "answer": "**ViewSet** объединяет логику для обработки всех CRUD действий (list, create, retrieve, update, delete) в одном классе.\n\n**Router** автоматически генерирует URL-конфигурацию для ViewSet.\n\nВместо написания 5 отдельных url patterns:\n```python\nrouter = DefaultRouter()\nrouter.register(r'users', UserViewSet)\nurlpatterns = router.urls\n```"
        },
        {
            "id": 50,
            "question": "FastAPI: Dependency Injection?",
            "category": "fastapi",
            "answer": "Система внедрения зависимостей через параметры функции.\n\n```python\nasync def get_db():\n    db = Session()\n    try: yield db\n    finally: db.close()\n\n@app.get(\"/\")\nasync def read_items(db: Session = Depends(get_db)):\n    ...\n```\nПозволяет переиспользовать логику (auth, db), легко подменять зависимости в тестах (override_dependency) и управлять скоупами."
        },
        {
            "id": 51,
            "question": "FastAPI vs Django: когда что выбрать?",
            "category": "web",
            "answer": "**Django**:\n- «Батарейки в комплекте» (Admin, ORM, Auth).\n- Быстрый старт для стандартных CRUD/CMS/E-commerce.\n- Монолитная архитектура.\n\n**FastAPI**:\n- Микросервисы, высокая производительность (Starlette).\n- Асинхронность из коробки.\n- Авто-документация (Swagger/OpenAPI).\n- Валидация данных (Pydantic).\n- Нужен полный контроль над архитектурой и выбором библиотек."
        },
        {
            "id": 52,
            "question": "Pydantic: валидация данных?",
            "category": "python_core",
            "answer": "Библиотека для парсинга и валидации данных с использованием Python Type Hints.\n\nЕсли данные не соответствуют схеме — выбрасывает `ValidationError`.\n\n```python\nclass User(BaseModel):\n    id: int\n    email: EmailStr\n    age: int = Field(gt=0)\n```\nИспользуется в FastAPI для валидации Request/Response body."
        },
        {
            "id": 53,
            "question": "JWT токены: Access и Refresh?",
            "category": "security",
            "answer": "**JSON Web Token** — stateless аутентификация.\n\n- **Access Token**: Короткоживущий (5-15 мин). Используется для запросов к API. Содержит claims (id, role).\n- **Refresh Token**: Долгоживущий (дни/недели). Используется ТОЛЬКО для получения новой пары токенов, когда Access протух.\n\nAccess хранят в памяти/httpOnly cookie. Refresh — в httpOnly cookie (безопасно) или БД (для возможности отзыва)."
        },
        {
            "id": 54,
            "question": "Что такое CORS?",
            "category": "web",
            "answer": "**Cross-Origin Resource Sharing**.\nМеханизм безопасности браузера, блокирующий запросы с одного домена на другой (например, с `localhost:3000` на `api.server.com`).\n\nСервер должен добавить заголовок `Access-Control-Allow-Origin` в ответ, чтобы разрешить браузеру прочитать данные.\n\nPreflight request (OPTIONS) отправляется браузером перед сложными запросами."
        },
        {
            "id": 55,
            "question": "Защита от SQL Injection?",
            "category": "security",
            "answer": "Внедрение вредоносного SQL кода через входные данные.\n\n**Защита**:\n1. Использовать **ORM** (Django/SQLAlchemy) — они экранируют данные.\n2. Использовать **параметризированные запросы** при работе с raw SQL:\n   `cursor.execute(\"SELECT * FROM users WHERE id = %s\", [user_id])`\n   НИКОГДА не использовать f-строки или конкатенацию для сборки SQL."
        },
        {
            "id": 56,
            "question": "WebSockets vs Polling vs Long Polling?",
            "category": "web",
            "answer": "- **Short Polling**: Клиент долбит сервер «есть новые данные?» каждые N сек. Высокая нагрузка, задержки.\n- **Long Polling**: Клиент ждет ответа. Сервер держит соединение пока не появятся данные или таймаут. Лучше, но все еще HTTP overhead.\n- **WebSockets**: Постоянный двунаправленный канал TCP. Минимальный overhead, мгновенная передача. Идеально для чатов, игр, бирж.\n- **SSE (Server-Sent Events)**: Односторонняя связь Сервер -> Клиент."
        },
        {
            "id": 57,
            "question": "Uvicorn vs Gunicorn?",
            "category": "devops",
            "answer": "- **Gunicorn**: WSGI сервер. Проверенный, стабильный, process-based worker model. Управляет процессами. Не умеет async сам по себе.\n- **Uvicorn**: ASGI сервер. Быстрый, асинхронный (uvloop). Умеет WebSockets.\n\n**Связка**: Gunicorn запускает и управляет рабочими процессами, а внутри каждого процесса работает Uvicorn Worker (`uvicorn.workers.UvicornWorker`) для обработки асинхронных запросов FastAPI/Django Channels."
        },
        {
            "id": 58,
            "question": "Что такое CSRF и как защититься?",
            "category": "security",
            "answer": "**Cross-Site Request Forgery** — атака, заставляющая браузер пользователя выполнить действие на другом сайте, где он залогинен (через cookie).\n\n**Защита**:\n- **CSRF Token**: Уникальный токен выдается сервером. Формы должны отправлять его обратно. Сервер проверяет.\n- **SameSite Cookie**: атрибут `SameSite=Strict/Lax` запрещает отправку кук при кросс-сайте.\n- Проверка `Referer` заголовка."
        },
        {
            "id": 59,
            "question": "GraphQL vs REST?",
            "category": "api",
            "answer": "- **REST**: Множество эндпоинтов. Фиксированная структура ответа. Over-fetching (получаем лишнее) или Under-fetching (нужно N запросов).\n- **GraphQL**: Один эндпоинт. Клиент запрашивает ровно те поля, которые нужны. Сильная типизация (Schema).\n\n**Плюсы GraphQL**: Гибкость для фронта, меньше трафика.\n**Минусы**: Сложность кэширования (все POST), сложность N+1, можно положить сервер сложным запросом."
        },
        {
            "id": 60,
            "question": "Что такое Web Server Gateway Interface (WSGI)?",
            "category": "python_core",
            "answer": "Стандарт взаимодействия (PEP 3333) между Python веб-приложением (Django/Flask) и веб-сервером (Nginx/Apache).\n\nПозволяет менять веб-серверы и фреймворки независимо друг от друга.\n\nФункция-обработчик принимает `environ` (словарь запроса) и `start_response` (функция для отправки заголовков), возвращает итерируемое тело ответа."
        },
        {
            "id": 61,
            "question": "Типы JOIN в SQL?",
            "category": "database",
            "answer": "1. **INNER JOIN**: только совпадающие строки из обеих таблиц.\n2. **LEFT (OUTER) JOIN**: все строки из левой + совпадающие из правой (или NULL).\n3. **RIGHT JOIN**: все из правой + левой.\n4. **FULL (OUTER) JOIN**: все строки из обеих таблиц (сочетание Left и Right).\n5. **CROSS JOIN**: декартово произведение (каждая строка с каждой)."
        },
        {
            "id": 62,
            "question": "Нормализация баз данных?",
            "category": "database",
            "answer": "Процесс организации данных для уменьшения избыточности и устранения аномалий.\n\n- **1НФ**: Атомарность значений (нет списков в ячейке), уникальность строк.\n- **2НФ**: 1НФ + все неключевые поля зависят от **всего** первичного ключа.\n- **3НФ**: 2НФ + нет транзитивных зависимостей (неключевые поля не зависят от других неключевых).\n\nНа практике обычно достаточно 3НФ. Денормализация используется для оптимизации чтения."
        },
        {
            "id": 63,
            "question": "Primary Key vs Unique Key?",
            "category": "database",
            "answer": "- **Primary Key (PK)**: Уникально идентифицирует строку. Не может быть NULL. Только один на таблицу. Обычно создается кластерный индекс.\n- **Unique Key**: Гарантирует уникальность. Может быть NULL (в SQL NULL != NULL, так что несколько NULL разрешены, но зависит от СУБД). Может быть несколько на таблицу."
        },
        {
            "id": 64,
            "question": "Redis Persistence: RDB vs AOF?",
            "category": "database",
            "answer": "Механизмы сохранения данных Redis на диск:\n\n1. **RDB (Snapshotting)**: Снапшоты данных раз в N минут. Компактный, быстро грузится. Минус: потеря данных за последние минуты при сбое.\n2. **AOF (Append Only File)**: Лог всех операций записи. Надежнее (fsync каждую секунду). Минус: файл больше, восстановление медленнее.\n\nОбычно используют комбинацию или только RDB для кэшей."
        },
        {
            "id": 65,
            "question": "Что такое транзакция и уровни изоляции?",
            "category": "database",
            "answer": "**Транзакция** — группа операций, выполняемых атомарно.\n\n**Уровни изоляции** (проблемы, которые решают):\n1. **Read Uncommitted**: Грязное чтение (видит незакоммиченное).\n2. **Read Committed**: (Default в PG) Нет грязного чтения. Возможно неповторяющееся чтение.\n3. **Repeatable Read**: Нет неповторяющегося чтения. Возможны фантомы.\n4. **Serializable**: Полная изоляция (как будто последовательно). Дорого."
        },
        {
            "id": 66,
            "question": "Soft Delete vs Hard Delete?",
            "category": "database",
            "answer": "- **Hard Delete**: `DELETE FROM table`. Данные физически удаляются. Необратимо.\n- **Soft Delete**: Поле `is_deleted` или `deleted_at`. Данные остаются, но фильтруются при выборке.\n\n**Плюсы Soft**: История, восстановление, целостность связей.\n**Минусы Soft**: Нужно везде добавлять фильтр `WHERE not deleted`, БД пухнет, уникальные индексы сложнее (нужно включать deleted поле)."
        },
        {
            "id": 67,
            "question": "SQL vs NoSQL?",
            "category": "database",
            "answer": "- **SQL (PostgreSQL, MySQL)**: Строгая схема, реляционные связи, ACID, мощные JOIN, вертикальное масштабирование.\n- **NoSQL (MongoDB, Redis, Cassandra)**: Гибкая схема (документы, ключ-значение), BASE (eventual consistency), горизонтальное масштабирование (sharding), высокая скорость записи.\n\nВыбор зависит от структуры данных и паттерна нагрузки."
        },
        {
            "id": 68,
            "question": "Что такое Sharding и Replication?",
            "category": "database",
            "answer": "- **Replication (Репликация)**: Копирование данных на другие сервера. Master-Slave. Повышает отказоустойчивость и скорость чтения (читаем со слейвов).\n- **Sharding (Шардирование)**: Распределение данных (разбиение таблицы) по разным серверам (по ключу). Повышает скорость записи и объем хранения.\n\nШардирование сложнее в поддержке (сложные JOIN, транзакции)."
        },
        {
            "id": 69,
            "question": "CAP теорема?",
            "category": "database",
            "answer": "В распределенной системе можно обеспечить только 2 из 3 свойств:\n1. **Consistency (Согласованность)**: Все узлы видят одни данные одновременно.\n2. **Availability (Доступность)**: Каждый запрос получает ответ (успех/неудача).\n3. **Partition Tolerance (Устойчивость к разделению)**: Система работает при потере связи между узлами.\n\nВ реальности выбор между CP (MongoDB) и AP (Cassandra), так как P неизбежно в сети."
        },
        {
            "id": 70,
            "question": "PostgreSQL: JSONB vs JSON?",
            "category": "database",
            "answer": "- **JSON**: Хранится как текст. Проверяет синтаксис. При каждом доступе парсится заново. Медленно.\n- **JSONB (Binary)**: Хранится в декомпозированном бинарном формате. Медленнее вставка, но намного быстрее чтение и индексация.\n\nВсегда используйте **JSONB**, если нужны операции с внутренностями JSON (поиск, фильтрация) и индексы (GIN)."
        },
        {
            "id": 71,
            "question": "Что такое View и Materialized View?",
            "category": "database",
            "answer": "- **View (Представление)**: Сохраненный SQL запрос. Виртуальная таблица. Данные вычисляются в момент обращения. Всегда свежие.\n- **Materialized View**: Физический снимок данных запроса. Занимает место. Быстрый доступ (не надо считать). Данные устаревают, нужно обновлять (`REFRESH MATERIALIZED VIEW`). Используется для тяжелой аналитики."
        },
        {
            "id": 72,
            "question": "Оконные функции SQL (Window Functions)?",
            "category": "database",
            "answer": "Позволяют выполнять вычисления по набору строк, связанных с текущей строкой, не группируя их в одну (в отличие от GROUP BY).\n\nПримеры: `ROW_NUMBER()`, `RANK()`, `LAG()`, `LEAD()`, `SUM() OVER (...)`.\n\n```sql\nSELECT name, salary, AVG(salary) OVER (PARTITION BY dept_id) \nFROM employees;\n```\nПоказывает зарплату сотрудника и среднюю по его отделу."
        },
        {
            "id": 73,
            "question": "Блокировки в БД (Pessimistic vs Optimistic)?",
            "category": "database",
            "answer": "- **Pessimistic Lock**: «Сначала заблокируй, потом делай». `SELECT FOR UPDATE`. Держит соединение и транзакцию. Гарантирует целостность, но снижает конкурентность.\n- **Optimistic Lock**: «Надейся на лучшее, проверяй версию». Добавляем поле `version`. При сохранении проверяем, что версия не изменилась. Если изменилась — кидаем ошибку и просим повторить. Не держит локов БД."
        },
        {
            "id": 74,
            "question": "Как ускорить медленный SQL запрос?",
            "category": "database",
            "answer": "1. `EXPLAIN ANALYZE` — посмотреть план выполнения.\n2. Проверить индексы (Index Scan vs Seq Scan).\n3. Убрать лишние JOIN или колонки (`SELECT *`).\n4. Проверить статистику (`ANALYZE`).\n5. Денормализация / Materialized View для тяжелых агрегатов.\n6. Кэширование результата."
        },
        {
            "id": 75,
            "question": "MongoDB: преимущества документарной модели?",
            "category": "database",
            "answer": "Данные хранятся в BSON (Binary JSON).\n\n**Плюсы**:\n- Гибкая схема (schema-less) — поля могут меняться.\n- Вложенность — можно хранить связанные данные внутри документа (Embedded), избегая JOIN.\n- Естественное маппинг на объекты кода.\n- Легкое горизонтальное масштабирование.\n\nХорошо для каталогов товаров, профилей пользователей, логов."
        },
        {
            "id": 76,
            "question": "Что такое Deadlock (Взаимная блокировка)?",
            "category": "database",
            "answer": "Ситуация, когда две транзакции ждут друг друга, чтобы освободить ресурсы.\n\nТ1 заблокировала А, ждет Б.\nТ2 заблокировала Б, ждет А.\n\n**Решение**:\n- СУБД обычно сама находит deadlock и убивает одну транзакцию.\n- В коде: всегда захватывать ресурсы в одном и том же порядке. Делать транзакции короткими."
        },
        {
            "id": 77,
            "question": "Что такое Connection Pool?",
            "category": "database",
            "answer": "Механизм переиспользования открытых соединений с БД.\nОткрытие соединения (Handshake) — дорогая операция.\n\nПул (PgBouncer, SQLAlchemy Pool) держит N открытых соединений и выдает их потокам по запросу. Это сильно увеличивает пропускную способность для коротких запросов."
        },
        {
            "id": 78,
            "question": "Kafka vs RabbitMQ?",
            "category": "devops",
            "answer": "- **RabbitMQ**: Message Queue. Smart broker, dumb consumer. Гарантия доставки, сложный роутинг. Сообщения удаляются после прочтения. Push-модель.\n- **Kafka**: Event Streaming Platform. Dumb broker, smart consumer. Хранит лог событий (не удаляет сразу). Pull-модель. Высочайшая пропускная способность. Используется для аналитики, ETL, Event Sourcing."
        },
        {
            "id": 79,
            "question": "Что такое Event Sourcing?",
            "category": "architecture",
            "answer": "Паттерн, где состояние системы определяется последовательностью событий (Events), а не текущим снимком в БД.\n\nВместо `UPDATE Order SET status='paid'` пишем событие `OrderPaid`.\n\n**Плюсы**: Полный аудит, возможность путешествия во времени, легкая аналитика.\n**Минусы**: Сложность, версионирование событий, snapshotting нужен для скорости."
        },
        {
            "id": 80,
            "question": "S3 (Object Storage) vs Block Storage?",
            "category": "devops",
            "answer": "- **Block Storage (HDD/SSD, EBS)**: Как обычный диск. Быстро, но дорого. Файловая система. Не шарится между серверами (обычно).\n- **Object Storage (S3, MinIO)**: Хранилище объектов по ключу (HTTP API). Плоская структура, метаданные. Бесконечно масштабируемо, дешево. Медленнее latency.\n\nДля медиа-файлов, бэкапов, статики используем S3."
        },
        {
            "id": 81,
            "question": "Принципы SOLID?",
            "category": "architecture",
            "answer": "1. **S (Single Responsibility)**: Класс должен иметь одну причину для изменения.\n2. **O (Open/Closed)**: Открыт для расширения, закрыт для модификации.\n3. **L (Liskov Substitution)**: Наследники должны заменять родителей без поломки логики.\n4. **I (Interface Segregation)**: Много маленьких интерфейсов лучше одного большого.\n5. **D (Dependency Inversion)**: Зависеть от абстракций, а не от деталей."
        },
        {
            "id": 82,
            "question": "Monolith vs Microservices?",
            "category": "architecture",
            "answer": "- **Монолит**: Единая кодовая база, один деплой. Проще начать, проще транзакции и отладка. Сложно масштабировать части, technology lock-in, запутанный код со временем (спагетти).\n- **Микросервисы**: Независимые сервисы. Свое хранилище. Общаются по сети. Легко масштабировать и менять технологии. Сложно: распределенные транзакции, мониторинг, деплой, сеть."
        },
        {
            "id": 83,
            "question": "Чистая архитектура (Clean Architecture)?",
            "category": "architecture",
            "answer": "Разделение кода на слои с правилом зависимостей: **внутренние слои не знают о внешних**.\n\n1. **Entities** (Доменная логика).\n2. **Use Cases** (Прикладная логика).\n3. **Adapters** (Контроллеры, Презентеры).\n4. **Frameworks/Drivers** (БД, Web, UI).\n\nПозволяет менять БД или фреймворк, не трогая бизнес-логику."
        },
        {
            "id": 84,
            "question": "Unit tests vs Integration tests?",
            "category": "testing",
            "answer": "- **Unit**: Тестируют модуль/функцию изолированно (с моками внешних зависимостей). Быстрые. Проверяют логику.\n- **Integration**: Тестируют взаимодействие компонентов (API + DB, Celery + Redis). Медленнее. Проверяют связность.\n- **E2E**: Тестируют весь сценарий пользователя в реальном окружении (Selenium/Playwright)."
        },
        {
            "id": 85,
            "question": "Что такое Mock и Patch?",
            "category": "testing",
            "answer": "Инструменты (`unittest.mock`) для подмены реальных объектов фиктивными во время тестов.\n\n**Зачем**:\n- Не делать реальные запросы к API/БД.\n- Симулировать ошибки (разрыв сети).\n- Проверить, что метод был вызван с нужными аргументами.\n\n`@patch('module.ClassName')` заменяет класс на Mock-объект."
        },
        {
            "id": 86,
            "question": "Pytest fixtures?",
            "category": "testing",
            "answer": "**Фикстуры** в pytest — функции для подготовки окружения (setup) и очистки (teardown).\n\n```python\n@pytest.fixture(scope=\"session\")\ndef db_conn():\n    conn = connect_db()\n    yield conn\n    conn.close()\n```\nМогут запрашивать другие фикстуры. Автоматически внедряются в тесты через аргументы. Удобнее `setUp/tearDown`."
        },
        {
            "id": 87,
            "question": "Git: Merge vs Rebase?",
            "category": "devops",
            "answer": "- **Merge**: Создает commit слияния. Сохраняет историю как она была (ветвление). Безопасно. История может стать запутанной.\n- **Rebase**: Переписывает историю, накладывая коммиты поверх новой базы. Линейная история. Опасно для публичных веток (меняет хэши коммитов).\n\nВ feature-ветках обычно делают rebase (clean history), в master вливают через squash merge."
        },
        {
            "id": 88,
            "question": "CI/CD: что это?",
            "category": "devops",
            "answer": "- **CI (Continuous Integration)**: Автоматическая сборка и тесты при каждом пуше. Раннее обнаружение багов.\n- **CD (Continuous Delivery/Deployment)**: Автоматический деплой проверенного кода на стейдж/прод.\n\nИнструменты: GitLab CI, GitHub Actions, Jenkins. Позволяет деплоить часто и без страха."
        },
        {
            "id": 89,
            "question": "12 Factor App (основные моменты)?",
            "category": "architecture",
            "answer": "Методология создания SaaS приложений.\nКлючевые пункты:\n1. Одна кодовая база, много деплоев.\n2. Зависимости явно объявлены.\n3. Конфигурация в переменных окружения (env).\n4. Сторонние службы (БД, кэш) как подключаемые ресурсы.\n5. Stateless процессы.\n6. Паритет разработки и продакшена."
        },
        {
            "id": 90,
            "question": "TDD (Test Driven Development)?",
            "category": "testing",
            "answer": "Разработка через тестирование. Цикл **Red-Green-Refactor**:\n1. **Red**: Пишем тест, который падает (функционала еще нет).\n2. **Green**: Пишем минимальный код, чтобы тест прошел.\n3. **Refactor**: Улучшаем код, сохраняя тесты зелеными.\n\nПлюсы: Высокое покрытие тестами, продуманный интерфейс. Минусы: Дольше писать сначала."
        },
        {
            "id": 91,
            "question": "Паттерн Singleton?",
            "category": "python_core",
            "answer": "Порождающий паттерн, гарантирующий, что у класса есть только один экземпляр.\n\nВ Python:\n1. Модуль (самый Pythonic способ) — импортируемый модуль инициализируется один раз.\n2. Через `__new__`.\n3. Через метакласс.\n\nИспользуется для конфигурации, логгеров, пулов соединений."
        },
        {
            "id": 92,
            "question": "Dependency Inversion vs Injection?",
            "category": "architecture",
            "answer": "- **Dependency Inversion (DIP)** — Принцип (SOLID). Модули верхнего уровня не должны зависеть от нижнего. Оба должны зависеть от абстракций.\n- **Dependency Injection (DI)** — Паттерн/Техника реализации DIP. Зависимости передаются в объект (через конструктор/аргументы), а не создаются внутри него."
        },
        {
            "id": 93,
            "question": "Что такое ELK стек?",
            "category": "devops",
            "answer": "Стек для сбора и анализа логов:\n- **Elasticsearch**: Поисковый движок и хранилище.\n- **Logstash** (или Fluentd): Сборщик и парсер логов.\n- **Kibana**: Визуализация (графики, поиск).\n\nПозволяет централизованно смотреть логи всех микросервисов, искать ошибки и строить дашборды."
        },
        {
            "id": 94,
            "question": "gRPC vs REST?",
            "category": "api",
            "answer": "- **REST**: Текстовый (JSON), HTTP/1.1, читаем человеком, нет строгой схемы контракта.\n- **gRPC**: Бинарный (Protobuf), HTTP/2, строгий контракт (.proto файлы), генерация кода клиентов, двунаправленный стриминг.\n\ngRPC эффективнее и быстрее для общения между микросервисами (internal), REST удобнее для публичных API."
        },
        {
            "id": 95,
            "question": "Паттерн Repository?",
            "category": "architecture",
            "answer": "Абстракция над слоем данных. Интерфейс для получения объектов, скрывающий детали реализации (SQL, ORM, API файл).\n\n```python\nclass UserRepository:\n    def get_by_id(self, id) -> User:\n        ...\n```\nПозволяет менять источники данных и тестировать бизнес-логику с мок-репозиторием без базы."
        },
        {
            "id": 96,
            "question": "Graceful Shutdown?",
            "category": "devops",
            "answer": "Корректное завершение приложения при получении сигнала (SIGTERM).\n1. Перестать принимать новые запросы.\n2. Дождаться завершения текущих запросов/задач.\n3. Закрыть соединения с БД/файлами.\n4. Выйти.\n\nВ Docker/K8s это критично, чтобы не обрывать соединения клиентов при деплое."
        },
        {
            "id": 97,
            "question": "Blue-Green Deployment?",
            "category": "devops",
            "answer": "Стратегия деплоя с нулевым простоем (Zero Downtime).\nЕсть два окружения: Blue (активное) и Green (новое).\n1. Деплоим новую версию на Green.\n2. Тестируем Green.\n3. Переключаем балансировщик трафика с Blue на Green.\n4. Если ошибки — переключаем обратно.\n\nТребует x2 ресурсов."
        },
        {
            "id": 98,
            "question": "Что такое Linux Load Average?",
            "category": "devops",
            "answer": "Среднее количество процессов, находящихся в состоянии выполнения (R) или ожидания ресурсов (D - disk sleep) за 1, 5, 15 минут.\n\nЕсли LA > количества ядер CPU — система перегружена, процессы ждут в очереди."
        },
        {
            "id": 99,
            "question": "Зачем нужен Nginx?",
            "category": "devops",
            "answer": "Reverse Proxy и Web Server.\n- Раздача статики (быстрее Python).\n- Балансировка нагрузки.\n- Терминация SSL/HTTPS.\n- Кэширование.\n- Gzip сжатие.\n- Защита от медленных клиентов.\n\nСтоит перед Gunicorn/Uvicorn."
        },
        {
            "id": 100,
            "question": "Как дебажить код в проде?",
            "category": "devops",
            "answer": "В проде нельзя использовать debugger (pdb)!\n1. **Логи** (ELK, CloudWatch) — основной инструмент.\n2. **Sentry** — агрегация ошибок с трейсбеками и контекстом переменных.\n3. **Метрики** (Prometheus/Grafana) — увидеть аномалии.\n4. **Tracing** (Jaeger/OpenTelemetry) — путь запроса через сервисы.\n5. Воспроизведение проблемы на стейдже с анонимизированными данными."
        },
        {
            "id": 101,
            "question": "Технический долг: как работать?",
            "category": "soft_skills",
            "answer": "**Техдолг** — это компромисс между скоростью и качеством.\n\n**Стратегия**:\n1. Не скрывать, а фиксировать (задачи в бэклоге с тегом tech-debt).\n2. Правило бойскаута: оставляй код чище, чем он был.\n3. Выделять квоту (например, 20% времени спринта) на рефакторинг.\n4. Объяснять бизнесу риски на языке денег (замедление разработки, баги)."
        },
        {
            "id": 102,
            "question": "Как вы проводите Code Review?",
            "category": "soft_skills",
            "answer": "1. **Стиль**: Сначала линтеры/CI, человек не должен искать пропущенные запятые.\n2. **Архитектура**: Понятно ли? Расширяемо? Безопасно?\n3. **Тон**: Уважительный. Не «Ты ошибся», а «Здесь может возникнуть проблема...».\n4. **Вопросы**: Задаю вопросы, чтобы понять контекст.\n5. **Похвала**: Отмечаю хорошие решения.\n\nЦель — качество кода и шаринг знаний, а не критика."
        },
        {
            "id": 103,
            "question": "Что делать, если продакшн упал?",
            "category": "soft_skills",
            "answer": "1. **Не паниковать**.\n2. **Откатить** последнее изменение (если причина в деплое) — приоритет №1 восстановить сервис.\n3. **Коммуникация**: Сообщить команде/клиентам, что «мы знаем и чиним».\n4. **Диагностика**: Логи, метрики.\n5. **Fix**: Исправить.\n6. **Post-mortem**: Разбор полетов. Почему случилось? Как предотвратить в будущем? (Без поиска виноватых)."
        },
        {
            "id": 104,
            "question": "Как менторить джуна?",
            "category": "soft_skills",
            "answer": "1. Не давать готовых решений. Задавать наводящие вопросы.\n2. Декомпозировать задачи вместе с ним.\n3. Code Review — подробно объяснять «почему», давать ссылки на доки.\n4. Поддерживать психологически, хвалить за прогресс.\n5. Давать право на ошибку в безопасной среде."
        },
        {
            "id": 105,
            "question": "Agile/Scrum: зачем это нужно?",
            "category": "soft_skills",
            "answer": "Гибкие методологии нужны для работы в условиях неопределенности.\n\n- **Итеративность**: Быстрая доставка ценности, быстрый фидбек от пользователя.\n- **Прозрачность**: Все знают, кто что делает.\n- **Адаптивность**: Планы меняются в ответ на изменения рынка.\n\nЦеремонии (Daily, Review, Retro) нужны для синхронизации и улучшения процессов."
        },
        {
            "id": 106,
            "question": "Как объяснить сложную техническую проблему бизнесу?",
            "category": "soft_skills",
            "answer": "Использовать **аналогии** и язык **выгоды/рисков**.\n\nПлохо: «Нам нужно рефакторить монолит на микросервисы, потому что высокая связность».\nХорошо: «Сейчас любая маленькая правка занимает 3 дня тестирования. Если мы разделим систему, сможем выпускать фичи за 1 день и снизим риск падения всего сайта»."
        },
        {
            "id": 107,
            "question": "Конфликт в команде: как решать?",
            "category": "soft_skills",
            "answer": "Пример: Спор о выборе технологии.\n1. Выслушать аргументы обеих сторон.\n2. Перевести спор в объективное русло: критерии, требования, метрики.\n3. Сделать PoC (Proof of Concept) или спайк.\n4. Принять решение коллегиально или лидом, зафиксировать reasons.\n\nГлавное — уважение и общая цель."
        },
        {
            "id": 108,
            "question": "Что такое YAGNI, KISS, DRY?",
            "category": "soft_skills",
            "answer": "- **KISS (Keep It Simple, Stupid)**: Не усложняй. Простое решение лучше умного.\n- **YAGNI (You Ain't Gonna Need It)**: Не делай фичи про запас. Реализуй только то, что нужно сейчас.\n- **DRY (Don't Repeat Yourself)**: Не дублируй логику/знания. Выноси в функции/константы."
        },
        {
            "id": 109,
            "question": "Как вы развиваетесь профессионально?",
            "category": "soft_skills",
            "answer": "1. Читаю тех. блоги/статьи (Habr, Medium, Real Python).\n2. Пет-проекты для пробы новых технологий.\n3. Конференции/Митапы (смотрю записи).\n4. Чтение чужого кода (Open Source).\n5. Изучаю смежные области (Frontend, DevOps)."
        },
        {
            "id": 110,
            "question": "Что делать, если не успеваешь в дедлайн?",
            "category": "soft_skills",
            "answer": "Сообщить **заранее** (как только понял), а не в день дедлайна.\nПредложить варианты:\n1. Урезать скоуп (сделать MVP).\n2. Привлечь помощь.\n3. Перенести срок (с обоснованием).\n\nХудшее — молчать и надеяться на чудо."
        },
        {
            "id": 111,
            "question": "Что такое идемпотентность API?",
            "category": "api",
            "answer": "Свойство метода: повторный вызов с теми же данными не меняет состояние сервера (результат тот же).\n\n- `GET`, `PUT`, `DELETE` — идемпотентны.\n- `POST` — НЕ идемпотентен (создает дубликаты).\n\nВажно при сетевых сбоях (клиент может безопасно повторить запрос)."
        },
        {
            "id": 112,
            "question": "HTTP/2 vs HTTP/1.1?",
            "category": "web",
            "answer": "**HTTP/2**:\n- Бинарный протокол (эффективнее парсинг).\n- **Мультиплексирование**: множество запросов через одно TCP соединение (нет head-of-line blocking).\n- Сжатие заголовков (HPACK).\n- Server Push.\n\nУскоряет загрузку страниц с кучей ресурсов."
        },
        {
            "id": 113,
            "question": "Что такое GIL (углубленно: atomic operations)?",
            "category": "python_core",
            "answer": "GIL не делает код потокобезопасным! Он защищает только внутренние структуры интерпретатора.\n\nОперации вроде `i += 1` не атомарны (read-modify-write). При переключении потока между read и write будет гонка данных.\nНужно использовать `threading.Lock` для защиты общих данных."
        },
        {
            "id": 114,
            "question": "Разница между `list.append` и `list.extend`?",
            "category": "python_core",
            "answer": "- `append(x)`: добавляет `x` как **один элемент** в конец списка.\n- `extend(iterable)`: итерируется по аргументу и добавляет **каждый элемент** в список.\n\n```python\na = [1]\na.append([2, 3]) # [1, [2, 3]]\na.extend([2, 3]) # [1, [2, 3], 2, 3]\n```"
        },
        {
            "id": 115,
            "question": "Hashable объекты?",
            "category": "python_core",
            "answer": "Объект **хэшируемый**, если у него есть хэш-значение (метод `__hash__`), которое не меняется за время жизни, и метод сравнения `__eq__`.\n\nВсе неизменяемые встроенные типы (int, str, tuple) — hashable.\nИзменяемые (list, dict, set) — unhashable.\n\nТолько hashable объекты могут быть ключами dict или элементами set."
        },
        {
            "id": 116,
            "question": "Как работает `set` внутри?",
            "category": "python_core",
            "answer": "Реализован как хэш-таблица (как dict, но без значений, только ключи).\n- Поиск/вставка/удаление: O(1) в среднем.\n- Порядок элементов не гарантируется (до Python 3.7+).\n- Требует хэшируемости элементов."
        },
        {
            "id": 117,
            "question": "Что такое `__call__`?",
            "category": "python_core",
            "answer": "Метод, позволяющий экземпляру класса вести себя как функция (быть вызываемым).\n\n```python\nclass Adder:\n    def __call__(self, x, y):\n        return x + y\n\nadd = Adder()\nprint(add(2, 3)) # 5\n```\nИспользуется для создания декораторов-классов и стратегий."
        },
        {
            "id": 118,
            "question": "Асинхронные генераторы?",
            "category": "python_core",
            "answer": "Генераторы, которые используют `async def` и могут делать `await` внутри, а также используют `yield`.\n\nИтерироваться по ним нужно через `async for`.\n\n```python\nasync def async_gen():\n    for i in range(3):\n        await asyncio.sleep(1)\n        yield i\n\nasync for item in async_gen():\n    print(item)\n```"
        },
        {
            "id": 119,
            "question": "Что такое Monkey Patching?",
            "category": "python_core",
            "answer": "Динамическая замена атрибутов/методов класса или модуля во время выполнения программы.\n\nИспользуется в тестах (gevent делает это с socket), но в продакшн коде считается плохой практикой (неявно меняет поведение, сложно отлаживать)."
        },
        {
            "id": 120,
            "question": "Разница между `__str__` и `__repr__`?",
            "category": "python_core",
            "answer": "- **`__str__`**: Для пользователей. Должен быть читаемым. Вызывается `print()` и `str()`.\n- **`__repr__`**: Для разработчиков. Должен быть однозначным (желательно валидным Python кодом для создания объекта). Вызывается в консоли/debugger.\n\nЕсли `__str__` не определен, используется `__repr__`."
        }
    ]
}